//! A crate for linear polynomial commitment schemes.
//! Supports verifier splitting into a succinct and non-succinct (or "hard") part,
//! and provides default implementations for more expressive evaluation claims:
//! * "multi-poly single-point", which uses the standard batching technique
//!   based on random linear combination,
//! * "multi-poly multi-point" which is the "batch evaluation" protocol from
//!   Boneh et al. [HaloInfinite]
//! The crate additionally implements generic domain extension of linear polynomial
//! commitment schemes as described in [Darlin].
//!
//! [HaloInfinite]: https://eprint.iacr.org/2020/1536
//! [Darlin]: https://eprint.iacr.org/2021/930/20210709:180459
#![deny(unused_import_braces, unused_qualifications, trivial_casts)]
#![deny(trivial_numeric_casts, private_in_public, variant_size_differences)]
#![deny(stable_features, unreachable_pub, non_shorthand_field_patterns)]
#![deny(unused_attributes, unused_mut)]
#![deny(missing_docs)]
#![deny(unused_imports)]
#![deny(renamed_and_removed_lints, stable_features, unused_allocation)]
#![deny(unused_comparisons, bare_trait_objects, unused_must_use, const_err)]
#![forbid(unsafe_code)]
#![allow(
    clippy::upper_case_acronyms,
    clippy::too_many_arguments,
    clippy::type_complexity,
    clippy::try_err,
    clippy::map_collect_result_unit,
    clippy::not_unsafe_ptr_arg_deref,
    clippy::suspicious_op_assign_impl,
    clippy::assertions_on_constants
)]

#[macro_use]
extern crate derivative;
#[macro_use]
extern crate bench_utils;

#[cfg(test)]
mod tests;

use crate::fiat_shamir_rng::FiatShamirRng;
pub use algebra::fft::DensePolynomial as Polynomial;
use algebra::{
    serialize::*, to_bytes, Curve, Field, Group, LinearCombination, SemanticallyValid, ToBytes,
};
use rand_core::RngCore;
use std::{
    collections::{BTreeMap, BTreeSet},
    fmt::Debug,
    iter::FromIterator,
    rc::Rc,
    string::{String, ToString},
    vec::Vec,
};

// use rayon::prelude::*;

/// A sponge-like random oracle for Fiat-Shamir transform usage.
pub mod fiat_shamir_rng;

/// Data structures for linear polynomial commitment schemes.
pub mod data_structures;
pub use data_structures::*;

/// Errors pertaining to query sets.
pub mod error;
pub use error::*;

/// A random number generator that bypasses some limitations of the Rust borrow
/// checker.
pub mod optional_rng;

/// Domain extension of [`PolynomialCommitment`].
pub mod domain_extended;
pub use domain_extended::*;

/// The [BCMS20](https://eprint.iacr.org/2020/499) variant of the dlog commitment scheme.
pub mod ipa_pc;

/// `QuerySet` is the set of queries that are to be made to a set of labeled polynomials or linear combinations.
///
///  Each element of a `QuerySet` is a pair of `(label, (point_label, point))`, where
///  * `label` is the label of a polynomial in `p`,
///  * `point_label` is the label for the point (e.g., "beta"), and  and
///  * `point` is the field element that `p[label]` is to be queried at.
pub type QuerySet<'a, F> = BTreeSet<(String, (String, F))>;

/// `Evaluations` is the result of querying a set of labeled polynomials or linear combinations
/// `p` at a `QuerySet` `Q`.
///
/// It maps each element of `Q` to the resulting evaluation.
/// That is, if `(label, query)` is an element of `Q`, then `evaluation.get((label, query))`
/// should equal `p[label].evaluate(query)`.
pub type Evaluations<'a, F> = BTreeMap<(String, F), F>;

/// Describes the interface for a homomorphic polynomial commitment scheme with values
/// in a commitment group `G`.  
///
/// The simple single-polynomial evaluation proof depends on the conrete scheme, whereas
/// more expressive opening proofs are reduced to a simple one by leveraging the homomorphic
/// properties.
/// The interface comes with the additional feature of splitting the verifier into a
/// `succinct` part and `non-succinct` part.   
pub trait PolynomialCommitment<G: Curve>: Sized {
    /// The polynomial commitment parameters for the commitment scheme.
    type Parameters: PCParameters<
        G,
        CommitterKey = Self::CommitterKey,
        VerifierKey = Self::VerifierKey,
        Error = Self::Error,
    >;
    /// The committer key for the scheme; used to commit to a polynomial and then
    /// open the commitment to produce an evaluation proof.
    type CommitterKey: PCCommitterKey;
    /// The verifier key for the scheme; used to check an evaluation proof.
    type VerifierKey: PCVerifierKey;
    /// The verifier state; generated by succinct verify.
    type VerifierState: PCVerifierState;
    /// The output of hard verify.
    type VerifierOutput: PCVerifierOutput;
    /// The commitment to a polynomial.
    type Commitment: Group<ScalarField = G::ScalarField>;
    /// The commitment randomness.
    type Randomness: Group<ScalarField = G::ScalarField>;
    /// A `simple' evaluation proof for single-point (single- or multi-poly) assertions.
    type Proof: PCProof;
    /// A batch evaluation proof in the sense of Boneh (et al.) contains an additional commitment.
    type MultiPointProof: PCMultiPointProof<G, Proof = Self::Proof, Commitment = Self::Commitment>;
    /// The error type for the scheme.
    type Error: std::error::Error + From<Error>;
    /// The stateful Fiat-Shamir random number generator.
    type RandomOracle: FiatShamirRng<Error = Self::Error>;

    /// Constructs public parameters when given as input the maximum degree `degree`
    /// for the polynomial commitment scheme.
    fn setup(max_degree: usize) -> Result<Self::Parameters, Self::Error>;

    /// Constructs public parameters when given as input the maximum degree `degree`
    /// for the polynomial commitment scheme from given seed
    fn setup_from_seed(max_degree: usize, seed: &[u8]) -> Result<Self::Parameters, Self::Error>;

    /// Computes the commitment of a single polynomial
    fn commit(
        ck: &Self::CommitterKey,
        polynomial: &Polynomial<G::ScalarField>,
        // Set `is_hiding = true` for hiding commitments
        is_hiding: bool,
        // rng for hiding randomness
        rng: Option<&mut dyn RngCore>,
    ) -> Result<(Self::Commitment, Self::Randomness), Self::Error>;

    /// Single-point multi-poly open, for proving an evaluation claim `p(x) = y`
    /// at a query point `x`.
    /// Note: It is assumed that the state of the Fiat-Shamir random number generator `fs_rng`
    /// is already bound to the evaluation claim, i.e. the commitment of `polynomial`,
    /// the point `x`, and the value `y`.
    ///
    // TODO: As this is the interface for a general homomorphic scheme, we should overthink
    // if it makes sense to pass also the commitment of `polynomial`, even if not needed
    // in the case of the dlog scheme.
    fn open(
        ck: &Self::CommitterKey,
        polynomial: Polynomial<G::ScalarField>,
        point: G::ScalarField,
        // Set `is_hiding = true` for zk of the evaluation proof.
        // TODO: let us rename it to `zk`
        is_hiding: bool,
        hiding_randomness: Self::Randomness,
        fs_rng: &mut Self::RandomOracle,
        // The optional rng for additional internal randomness of open()
        rng: Option<&mut dyn RngCore>,
    ) -> Result<Self::Proof, Self::Error>;

    /// The succinct part of `verify()`.
    fn succinct_verify(
        vk: &Self::VerifierKey,
        commitment: &Self::Commitment,
        point: G::ScalarField,
        value: G::ScalarField,
        proof: &Self::Proof,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<Option<Self::VerifierState>, Self::Error>;

    /// The hard part of `verify()`.
    fn hard_verify(
        vk: &Self::VerifierKey,
        vs: &Self::VerifierState,
    ) -> Result<Option<Self::VerifierOutput>, Self::Error>;

    /// Single-point single-poly verify. Verifies a proof produced by `fn open()`.
    /// The verification function of an opening proof produced by `fn open()`
    fn verify<'a>(
        vk: &Self::VerifierKey,
        commitment: &Self::Commitment,
        point: G::ScalarField,
        value: G::ScalarField,
        proof: &Self::Proof,
        // This implementation assumes that the commitments, point and evaluations are already absorbed by the Fiat Shamir rng
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<bool, Self::Error> {
        let check_time = start_timer!(|| "Checking evaluations");

        let verifier_state = Self::succinct_verify(vk, commitment, point, value, proof, fs_rng)?;

        if verifier_state.is_none() {
            end_timer!(check_time);
            Err(Error::FailedSuccinctCheck)?
        }

        let res = Self::hard_verify(vk, &verifier_state.unwrap())?;

        end_timer!(check_time);

        if res.is_some() {
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Open a linear combination at a single query point.
    /// Note: this default implementation demands that the state of the Fiat-Shamir
    /// rng is already bound to the evaluation claim (i.e. the linear combination,
    /// the query point and the value).
    fn open_lc<'a>(
        ck: &Self::CommitterKey,
        polynomials_lc: &'a LinearCombination<Polynomial<G::ScalarField>>,
        point: G::ScalarField,
        is_hiding: bool,
        randomnesses_lc: &'a LinearCombination<Self::Randomness>,
        fs_rng: &mut Self::RandomOracle,
        // The optional rng for additional internal randomness of open()
        rng: Option<&mut dyn RngCore>,
    ) -> Result<Self::Proof, Self::Error> {
        let lc_poly_time = start_timer!(|| "Combine polynomials LC");
        let polynomial = polynomials_lc.combine();
        end_timer!(lc_poly_time);

        let lc_rand_time = start_timer!(|| "Combine randomness LC");
        let randomness = randomnesses_lc.combine();
        end_timer!(lc_rand_time);

        Self::open(ck, polynomial, point, is_hiding, randomness, fs_rng, rng)
    }

    /// Verify proofs produced by `fn open_lc()`.
    fn verify_lc<'a>(
        vk: &Self::VerifierKey,
        commitments_lc: &'a LinearCombination<Self::Commitment>,
        point: G::ScalarField,
        value: G::ScalarField,
        proof: &Self::Proof,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<bool, Self::Error> {
        let lc_comm_time = start_timer!(|| "Combine commitments LC");
        let commitment = commitments_lc.combine();
        end_timer!(lc_comm_time);

        Self::verify(vk, &commitment, point, value, proof, fs_rng)
    }

    /// The succinct part of `verify_lc()`.
    fn succinct_verify_lc<'a>(
        vk: &Self::VerifierKey,
        commitments_lc: &'a LinearCombination<Self::Commitment>,
        point: G::ScalarField,
        value: G::ScalarField,
        proof: &Self::Proof,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<Option<Self::VerifierState>, Self::Error> {
        let lc_comm_time = start_timer!(|| "Combine commitments LC");
        let commitment = commitments_lc.combine();
        end_timer!(lc_comm_time);

        Self::succinct_verify(vk, &commitment, point, value, proof, fs_rng)
    }

    /// The vectorial variant of `fn commit()`. Outputs a vector of commitments
    /// to a set of `polynomials`.
    // If `polynomials[i].is_hiding()`, then the `i`-th commitment is hiding.
    // Hence `rng` should not be `None` if `polynomials[i].is_hiding() == true`
    // for some of the `i`s.
    // If for some `i`, `polynomials[i].is_hiding() == false`, then the
    // corresponding randomness is `G::ScalarField::empty()`.
    // TODO: up to now we only use it in test. Let us overthink if we really need it.
    fn commit_vec<'a>(
        ck: &Self::CommitterKey,
        labeled_polynomials: impl IntoIterator<Item = &'a LabeledPolynomial<G::ScalarField>>,
        // The optional rng for additional internal randomness of open()
        mut rng: Option<&mut dyn RngCore>,
    ) -> Result<
        (
            Vec<LabeledCommitment<Self::Commitment>>,
            Vec<LabeledRandomness<Self::Randomness>>,
        ),
        Self::Error,
    > {
        let mut labaled_commitments = Vec::new();
        let mut labeled_randomnesses = Vec::new();

        let commit_time = start_timer!(|| "Committing to polynomials");
        for labeled_polynomial in labeled_polynomials {
            let polynomial = labeled_polynomial.polynomial();
            let label = labeled_polynomial.label();
            let is_hiding = labeled_polynomial.is_hiding();

            let single_commit_time = start_timer!(|| format!(
                "Polynomial {} of degree {}, and hiding bound {:?}",
                label,
                polynomial.degree(),
                is_hiding,
            ));

            let (commitment, randomness) = Self::commit(
                ck,
                polynomial,
                is_hiding,
                if rng.is_some() {
                    Some(rng.as_mut().unwrap())
                } else {
                    None
                },
            )?;

            let labeled_commitment = LabeledCommitment::new(label.to_string(), commitment);
            let labeled_randomness = LabeledRandomness::new(label.to_string(), randomness);

            labaled_commitments.push(labeled_commitment);
            labeled_randomnesses.push(labeled_randomness);

            end_timer!(single_commit_time);
        }

        end_timer!(commit_time);
        Ok((labaled_commitments, labeled_randomnesses))
    }

    /// Single-point multi-poly open, for proving an evaluation claim
    ///     `p_i(x) = y_i`, `i=1,...,m`,
    /// sharing the same query point `x`. Reduces the batch of evaluation claims to
    /// that of a random linear combination.
    /// Note: this default implementation demands that the state of the Fiat-Shamir
    /// rng is already bound to the evaluation claim (i.e.  the commitments `label_commitments`,
    /// the point `x`, and the values `v_i`.).
    fn single_point_multi_poly_open<'a>(
        ck: &Self::CommitterKey,
        labeled_polynomials: impl IntoIterator<Item = &'a LabeledPolynomial<G::ScalarField>>,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        point: G::ScalarField,
        fs_rng: &mut Self::RandomOracle,
        labeled_randomnesses: impl IntoIterator<Item = &'a LabeledRandomness<Self::Randomness>>,
        // The optional rng for additional internal randomness of open()
        rng: Option<&mut dyn RngCore>,
    ) -> Result<Self::Proof, Self::Error> {
        // TODO: we can use LinearCombinations and open_lc(), now that we have it.

        let (combined_polynomial, combined_randomness, has_hiding) =
            Self::single_point_multi_poly_open_combine(
                labeled_polynomials,
                labeled_commitments,
                fs_rng,
                labeled_randomnesses,
            )?;

        Self::open(
            ck,
            combined_polynomial,
            point,
            has_hiding,
            combined_randomness,
            fs_rng,
            rng,
        )
    }

    /// The batch evaluation protocol from Boneh et al. [HaloInfinite], for proving a multi-point
    /// multi-poly assertion
    ///  `p_i(x_i) = y_i`, `i=1,...,m`
    /// for a set of `labeled_polynomials`.
    /// Note: this default implementation demands that the state of the Fiat-Shamir
    /// rng is already bound to the evaluation claim (i.e.  the commitments `label_commitments`,
    /// the query set, and the values `v_i`.).
    ///
    /// [HaloInfinite]: https://eprint.iacr.org/2020/1536
    fn multi_point_multi_poly_open<'a>(
        ck: &Self::CommitterKey,
        labeled_polynomials: impl IntoIterator<Item = &'a LabeledPolynomial<G::ScalarField>>,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        query_set: &QuerySet<G::ScalarField>,
        fs_rng: &mut Self::RandomOracle,
        labeled_randomnesses: impl IntoIterator<Item = &'a LabeledRandomness<Self::Randomness>>,
        // The optional rng for additional internal randomness of open()
        mut rng: Option<&mut dyn RngCore>,
    ) -> Result<Self::MultiPointProof, Self::Error> {
        // The multi-point multi-poly assertion is rephrased as polynomial identity over the query set
        // Q = {x_1,...,x_m},
        //
        //      Sum_i  lambda^i z_i(X) * (p_i(X) - y_i)  = h(X) * z(X),
        //
        // where `z_i(X) = Prod_{x_j!=x_i} (x - x_j)` and `z(X)` is the vanishing polynomial of the
        // query set. The identity is proven by providing h(X) and showing that for a random x outside
        // the query set, the "mult-point multi-poly opening combination"
        //
        //       LC_x(p_i(X),h(X)) = Sum_i  lambda^i z_i(x)/z(x) * p_i(X)  - h(X)
        //
        // opens to the expected value `v = Sum_i lambda^i z_i(x)/z(x)* y_i`.
        let batch_time = start_timer!(|| "Multi poly multi point batching.");

        // TODO: we can use LinearCombinations and open_lc(), now that we have it.

        let (combined_polynomial, combined_point, combined_randomness, has_hiding, h_commitment) =
            Self::multi_point_multi_poly_open_combine(
                ck,
                labeled_polynomials,
                labeled_commitments,
                query_set,
                fs_rng,
                labeled_randomnesses,
                if rng.is_some() {
                    Some(rng.as_mut().unwrap())
                } else {
                    None
                },
            )?;

        let proof = Self::open(
            ck,
            combined_polynomial,
            combined_point,
            has_hiding,
            combined_randomness,
            fs_rng,
            rng,
        )?;

        end_timer!(batch_time);

        Ok(Self::MultiPointProof::new(proof, h_commitment.clone()))
    }

    /// The verifier for proofs generated by `fn single_point_multi_poly_open()`.
    fn single_point_multi_poly_verify<'a>(
        vk: &Self::VerifierKey,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        point: G::ScalarField,
        values: impl IntoIterator<Item = G::ScalarField>,
        proof: &Self::Proof,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<bool, Self::Error> {
        // TODO: we can use LinearCombinations and verifiy_lc()

        let (combined_commitment, combined_value) =
            Self::single_point_multi_poly_verify_combine(labeled_commitments, values, fs_rng)?;

        Self::verify(
            vk,
            &combined_commitment,
            point,
            combined_value,
            proof,
            fs_rng,
        )
    }

    /// The succinct part of `single_point_multi_poly_verify()`.
    fn succinct_single_point_multi_poly_verify<'a>(
        vk: &Self::VerifierKey,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        point: G::ScalarField,
        values: impl IntoIterator<Item = G::ScalarField>,
        proof: &Self::Proof,
        // This implementation assumes that the commitments, point and evaluations are
        // already bound to the internal state of the Fiat Shamir rng
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<Option<Self::VerifierState>, Self::Error> {
        let (combined_commitment, combined_value) =
            Self::single_point_multi_poly_verify_combine(labeled_commitments, values, fs_rng)?;

        Self::succinct_verify(
            vk,
            &combined_commitment,
            point,
            combined_value,
            proof,
            fs_rng,
        )
    }

    /// The verifier for proofs generated by `fn multi_point_multi_poly_open()`.
    fn multi_point_multi_poly_verify<'a>(
        vk: &Self::VerifierKey,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        query_set: &QuerySet<G::ScalarField>,
        evaluations: &Evaluations<G::ScalarField>,
        multi_point_proof: &Self::MultiPointProof,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<bool, Self::Error> {
        let (combined_commitment, combined_value, combined_point) =
            Self::multi_point_multi_poly_verify_combine(
                labeled_commitments,
                query_set,
                evaluations,
                multi_point_proof,
                fs_rng,
            )?;

        Self::verify(
            vk,
            &combined_commitment,
            combined_point,
            combined_value,
            multi_point_proof.get_proof(),
            fs_rng,
        )
    }

    /// The succinct part of `multi_point_multi_poly_verify()`.
    fn succinct_multi_point_multi_poly_verify<'a>(
        vk: &Self::VerifierKey,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        query_set: &QuerySet<G::ScalarField>,
        evaluations: &Evaluations<G::ScalarField>,
        multi_point_proof: &Self::MultiPointProof,
        // This implementation assumes that the commitments, query set and evaluations are already absorbed by the Fiat Shamir rng
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<Option<Self::VerifierState>, Self::Error> {
        let (combined_commitment, combined_value, combined_point) =
            Self::multi_point_multi_poly_verify_combine(
                labeled_commitments,
                query_set,
                evaluations,
                multi_point_proof,
                fs_rng,
            )?;

        Self::succinct_verify(
            vk,
            &combined_commitment,
            combined_point,
            combined_value,
            multi_point_proof.get_proof(),
            fs_rng,
        )
    }

    /// Build the multi-poly single-point (random) linear combination.
    // TODO: let us declare this function as internal.
    fn single_point_multi_poly_open_combine<'a>(
        labeled_polynomials: impl IntoIterator<Item = &'a LabeledPolynomial<G::ScalarField>>,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        fs_rng: &mut Self::RandomOracle,
        labeled_randomnesses: impl IntoIterator<Item = &'a LabeledRandomness<Self::Randomness>>,
    ) -> Result<
        (
            Polynomial<G::ScalarField>, // the random linear combination of the p_i(X)
            Self::Randomness,           // their combined commitment randomnesses.
            bool, // `is_hiding` for the batch of polynomial. Is `true` if one of the p_i(X) needs hiding.
        ),
        Self::Error,
    > {
        let combine_time = start_timer!(|| "Combining polynomials, randomness, and commitments.");

        let mut combined_polynomial = Polynomial::zero();
        let mut combined_randomness = Self::Randomness::zero();

        let mut has_hiding = false;

        let polys_iter = labeled_polynomials.into_iter();
        let rands_iter = labeled_randomnesses.into_iter();
        let comms_iter = labeled_commitments.into_iter();

        // as the statement/assertion of the opening proof is already bound to the interal state
        // of the fr_rng, we simply squeeze the challenge scalar for the random linear combination
        let lambda: G::ScalarField = fs_rng.squeeze_128_bits_challenge();
        let mut cur_challenge = G::ScalarField::one();

        // compute the random linear combination using the powers of lambda
        for (labeled_polynomial, (labeled_commitment, labeled_randomness)) in
            polys_iter.zip(comms_iter.zip(rands_iter))
        {
            if labeled_polynomial.label() != labeled_commitment.label() {
                end_timer!(combine_time);
                Err(Error::Other(
                    format!(
                        "Labels are not equal: poly '{}'. commitment '{}'",
                        labeled_polynomial.label(),
                        labeled_commitment.label()
                    )
                    .to_owned(),
                ))?
            }

            let polynomial = labeled_polynomial.polynomial();
            let is_hiding = labeled_polynomial.is_hiding();
            let randomness = labeled_randomness.randomness();

            if is_hiding {
                has_hiding = true;
            }

            // TODO: look for arithmetic operations optimization and removing clone
            // add segment linear combination to overall combination,
            // both for witnesses, commitments (and their randomnesses, if hiding)
            combined_polynomial += (cur_challenge, polynomial);
            if has_hiding {
                combined_randomness += &(randomness.clone() * &cur_challenge);
            }

            // next power of lambda
            cur_challenge = cur_challenge * &lambda;
        }

        end_timer!(combine_time);

        Ok((combined_polynomial, combined_randomness, has_hiding))
    }

    /// Build the multi-point multi-poly opening combination.
    ///       LC_x(p_i(X),h(X)) = Sum_i  lambda^i z_i(x)/z(x) * p_i(X)  - h(X)
    // TODO: let us declare this function as internal.
    fn multi_point_multi_poly_open_combine<'a>(
        ck: &Self::CommitterKey,
        labeled_polynomials: impl IntoIterator<Item = &'a LabeledPolynomial<G::ScalarField>>,
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        query_set: &QuerySet<G::ScalarField>,
        fs_rng: &mut Self::RandomOracle,
        labeled_randomnesses: impl IntoIterator<Item = &'a LabeledRandomness<Self::Randomness>>,
        mut rng: Option<&mut dyn RngCore>,
    ) -> Result<
        (
            Polynomial<G::ScalarField>, // the polynomial h(X)
            G::ScalarField,             // the new random challenge challenge
            Self::Randomness,           // the (optional) commitment randomness of h(X)
            bool, // `is_hiding` for the batch. Is `true` if one of the involved polynomials needs hiding.
            Self::Commitment, // the commitment of h(X)
        ),
        Self::Error,
    >
// where
        //     G: Group<ScalarField = <Self::Randomness as Group>::ScalarField>
    {
        let combine_time = start_timer!(|| "Combining polynomials, randomness, and commitments.");

        let poly_map: BTreeMap<_, _> = labeled_polynomials
            .into_iter()
            .map(|poly| (poly.label(), poly))
            .collect();

        let rands_map: BTreeMap<_, _> = labeled_randomnesses
            .into_iter()
            .map(|rand| (rand.label(), rand))
            .collect();

        let commitment_map: BTreeMap<_, _> = labeled_commitments
            .into_iter()
            .map(|commitment| (commitment.label(), commitment))
            .collect();

        // as the statement of the opening proof is already bound to the interal state of the fs_rng,
        // we simply squeeze the challenge scalar for the random linear combination
        let lambda: G::ScalarField = fs_rng.squeeze_128_bits_challenge();
        let mut cur_challenge = G::ScalarField::one();

        let mut has_hiding = false;

        let h_poly_time = start_timer!(|| "Compute h(X) polynomial");

        // h(X)
        let mut h_polynomial = Polynomial::zero();

        // z(X), the vanishing polynomial of the query set.
        let mut z_polynomial = Polynomial::from_coefficients_slice(&[G::ScalarField::one()]);

        // Save evaluation points for later
        let mut eval_points = std::collections::HashSet::new();

        // Collect middleware results into vectors
        let mut x_polynomials = vec![];
        let mut polynomials = vec![];
        let mut randomnesses = vec![];

        for (label, (_point_label, point)) in query_set.iter() {
            eval_points.insert(*point);

            if !commitment_map.contains_key(label) {
                end_timer!(combine_time);
                Err(Error::MissingCommitment {
                    label: label.to_string(),
                })?
            }

            let labeled_polynomial = *poly_map.get(label).ok_or(Error::MissingPolynomial {
                label: label.to_string(),
            })?;

            let labeled_randomness = *rands_map.get(label).ok_or(Error::MissingRandomness {
                label: label.to_string(),
            })?;

            if labeled_polynomial.is_hiding() {
                has_hiding = true;
            }

            // y_i
            let y_i = labeled_polynomial.polynomial().evaluate(*point);

            // (X - x_i)
            let x_polynomial =
                Polynomial::from_coefficients_slice(&[-(*point), G::ScalarField::one()]);

            // z(X) = PROD (X - x_i)
            z_polynomial = z_polynomial.naive_mul(&x_polynomial);

            // (p_i(X) - y_i) / (X - x_i)
            let polynomial = &(labeled_polynomial.polynomial()
                - &Polynomial::from_coefficients_slice(&[y_i]))
                / &x_polynomial;

            // h(X) = SUM( lambda^i * ((p_i(X) - y_i) / (X - x_i)) )
            h_polynomial += (cur_challenge, &polynomial);

            // lambda^i
            cur_challenge = cur_challenge * &lambda;

            polynomials.push(labeled_polynomial.polynomial());
            x_polynomials.push(x_polynomial);
            randomnesses.push(labeled_randomness.randomness());
        }

        end_timer!(h_poly_time);

        let commit_time = start_timer!(|| format!(
            "Commit to h(X) polynomial of degree {}",
            h_polynomial.degree()
        ));

        let (h_commitment, h_randomness) = Self::commit(
            ck,
            &h_polynomial,
            has_hiding,
            if has_hiding {
                if rng.is_none() {
                    end_timer!(commit_time);
                    Err(Error::Other("Rng not set".to_owned()))?
                }
                Some(rng.as_mut().unwrap())
            } else {
                None
            },
        )?;

        end_timer!(commit_time);

        let open_time = start_timer!(|| "Open LC(p_1(X),p_2(X),...,p_m(X),h(X)) polynomial");

        // Fresh random challenge x for multi-point to single-point reduction.
        // Except the `batch_commitment`, all other commitments are already bound
        // to the internal state of the Fiat-Shamir
        fs_rng.absorb(&to_bytes![h_commitment].unwrap());
        let x_point: G::ScalarField = fs_rng.squeeze_128_bits_challenge();

        // Assert x_point != x_1, ..., x_m
        // This is needed as we use a slightly optimized LC, which costs one
        // scalar multiplication.
        if eval_points.iter().any(|eval_point| eval_point == &x_point) {
            end_timer!(open_time);
            end_timer!(combine_time);
            Err(Error::Other(
                "Squeezed a challenge equal to one of the evaluation points".to_owned(),
            ))?
        }

        // LC(p_1(X),p_2(X),...,p_m(X),h(X))
        // TODO: let us use LinearCombinations here, too
        let mut lc_polynomial = Polynomial::zero();
        let mut lc_randomness = Self::Randomness::zero();

        let mut cur_challenge = G::ScalarField::one();

        for ((&polynomial, x_polynomial), &randomness) in polynomials
            .iter()
            .zip(x_polynomials.iter())
            .zip(randomnesses.iter())
        {
            let z_i_over_z_value = x_polynomial.evaluate(x_point).inverse().unwrap();

            // LC(p_1(X),p_2(X),...,p_m(X)) = SUM ( lamda^i * z_i(x)/z(x) * p_i(X) )
            lc_polynomial += (cur_challenge * z_i_over_z_value, polynomial);

            if has_hiding {
                lc_randomness += &(randomness.clone() * &(cur_challenge * z_i_over_z_value));
            }

            // lambda^i
            cur_challenge = cur_challenge * &lambda;
        }

        // LC(p_1(X),p_2(X),...,p_m(X),h(X)) = SUM ( lamda^i * z_i(x)/z(x) * p_i(X) ) -  h(X)
        lc_polynomial -= &h_polynomial;

        if has_hiding {
            lc_randomness += &-h_randomness;
        }

        end_timer!(open_time);
        end_timer!(combine_time);

        Ok((
            lc_polynomial,
            x_point,
            lc_randomness,
            has_hiding,
            h_commitment,
        ))
    }

    /// Single point multi poly combine function. Recomputes the random linear combination
    /// output by `fn single_point_multi_poly_combine()` in terms of their commitments.
    // TODO: let us declare this function as internal.
    fn single_point_multi_poly_verify_combine<'a>(
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        values: impl IntoIterator<Item = G::ScalarField>,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<
        (
            Self::Commitment, // the linear combination of the commitments
            G::ScalarField,   // the expected opening value
        ),
        Self::Error,
    > {
        let combine_time = start_timer!(|| "Single point multi poly verify combine time");

        let mut combined_commitment = Self::Commitment::zero();
        let mut combined_value = G::ScalarField::zero();

        let lambda: G::ScalarField = fs_rng.squeeze_128_bits_challenge();
        let mut cur_challenge = G::ScalarField::one();

        let labeled_commitments_iter = labeled_commitments.into_iter();
        let values_iter = values.into_iter();

        for (labeled_commitment, value) in labeled_commitments_iter.zip(values_iter) {
            let commitment = labeled_commitment.commitment();
            combined_value += &(cur_challenge * &value);

            if cur_challenge == G::ScalarField::one() {
                combined_commitment = commitment.clone();
            } else {
                combined_commitment += &(commitment.clone() * &cur_challenge);
            }

            cur_challenge *= &lambda;
        }

        end_timer!(combine_time);

        Ok((combined_commitment, combined_value))
    }

    /// Recomputes the "multi-point multi-poly combination" as output by `fn multi_point_multi_poly_combine()`
    /// in terms of their commitments.
    // TODO: let us declare this function as internal.
    fn multi_point_multi_poly_verify_combine<'a>(
        labeled_commitments: impl IntoIterator<Item = &'a LabeledCommitment<Self::Commitment>>,
        query_set: &QuerySet<G::ScalarField>,
        evaluations: &Evaluations<G::ScalarField>,
        multi_point_proof: &Self::MultiPointProof,
        fs_rng: &mut Self::RandomOracle,
    ) -> Result<
        (
            Self::Commitment, // the commitment for the linear combination LC_x()
            G::ScalarField,   // the expected opening value
            G::ScalarField,   // the random challenge x
        ),
        Self::Error,
    > {
        let combine_time = start_timer!(|| "Multi point multi poly verify combine time");

        let commitment_map: BTreeMap<_, _> = labeled_commitments
            .into_iter()
            .map(|commitment| (commitment.label(), commitment))
            .collect();

        // lambda
        let lambda: G::ScalarField = fs_rng.squeeze_128_bits_challenge();
        let mut cur_challenge = G::ScalarField::one();

        // Fresh random challenge x
        fs_rng.absorb(&to_bytes![multi_point_proof.get_h_commitment()].unwrap());
        let x_point: G::ScalarField = fs_rng.squeeze_128_bits_challenge();

        // LC(C): reconstructed commitment to LC(p_1(X),p_2(X),...,p_m(X),h(X))
        let mut lc_commitment = Self::Commitment::zero();

        // Expected value wich LC(p_1(X),p_2(X),...,p_m(X),h(X)) opens to
        let mut lc_value = G::ScalarField::zero();

        for (label, (_point_label, point)) in query_set.iter() {
            // Assert x_point != x_1, ..., x_m
            if point == &x_point {
                Err(Error::Other(
                    "Squeezed a challenge equal to one of the evaluation points".to_owned(),
                ))?
            }

            let labeled_commitment =
                *commitment_map.get(label).ok_or(Error::MissingCommitment {
                    label: label.to_string(),
                })?;

            // y_i
            let y_i =
                *evaluations
                    .get(&(label.clone(), *point))
                    .ok_or(Error::MissingEvaluation {
                        label: label.to_string(),
                    })?;

            // (X - x_i)
            let x_polynomial =
                Polynomial::from_coefficients_slice(&[-(*point), G::ScalarField::one()]);

            // z_i(x)/z(x) = 1 / (x - x_i).
            // unwrap cannot fail as x-x_i is guaranteed to be non-zero.
            let z_i_over_z_value = x_polynomial.evaluate(x_point).inverse().unwrap();

            lc_commitment +=
                &(labeled_commitment.commitment().clone() * &(z_i_over_z_value * cur_challenge));

            lc_value += y_i * cur_challenge * z_i_over_z_value;

            // lambda^i
            cur_challenge = cur_challenge * &lambda;
        }

        lc_commitment += &(-multi_point_proof.get_h_commitment().clone());

        end_timer!(combine_time);

        Ok((lc_commitment, lc_value, x_point))
    }

    /// Succinct verify (a batch of) multi-point multi-poly opening proofs and, if valid,
    /// return their SuccinctCheckPolynomials (the reduction challenges `xi`) and the
    /// final committer keys `GFinal`.
    fn batch_succinct_verify<'a>(
        vk: &Self::VerifierKey,
        commitments: impl IntoIterator<Item = &'a [LabeledCommitment<Self::Commitment>]>,
        query_sets: impl IntoIterator<Item = &'a QuerySet<'a, G::ScalarField>>,
        values: impl IntoIterator<Item = &'a Evaluations<'a, G::ScalarField>>,
        multi_point_proofs: impl IntoIterator<Item = &'a Self::MultiPointProof>,
        states: impl IntoIterator<Item = &'a <Self::RandomOracle as FiatShamirRng>::State>,
    ) -> Result<Vec<Self::VerifierState>, Self::Error>
    where
        Self::Commitment: 'a,
        Self::MultiPointProof: 'a,
        Self::RandomOracle: 'a,
    {
        let comms = commitments.into_iter().collect::<Vec<_>>();
        let query_sets = query_sets.into_iter().collect::<Vec<_>>();
        let values = values.into_iter().collect::<Vec<_>>();
        let multi_point_proofs = multi_point_proofs.into_iter().collect::<Vec<_>>();
        let states = states.into_iter().collect::<Vec<_>>();

        // Perform succinct verification of all the proofs and collect
        // the xi_s and the GFinal_s into DLogAccumulators
        let succinct_time = start_timer!(|| "Succinct verification of proofs");

        // TODO: into_par_iter should be used
        let (accumulators, failed_checks): (
            Vec<Result<_, Self::Error>>,
            Vec<Result<_, Self::Error>>,
        ) = comms
            .into_iter()
            .zip(query_sets)
            .zip(values)
            .zip(multi_point_proofs)
            .zip(states)
            .map(
                |((((commitments, query_set), values), multi_point_proof), state)| {
                    let mut fs_rng = Self::RandomOracle::default();
                    fs_rng.set_state(state.clone());

                    // Perform succinct check of i-th proof
                    let verfifier_state = Self::succinct_multi_point_multi_poly_verify(
                        vk,
                        commitments,
                        query_set,
                        values,
                        multi_point_proof,
                        &mut fs_rng,
                    )?;

                    if verfifier_state.is_none() {
                        Err(Error::FailedSuccinctCheck)?
                    }

                    Ok(verfifier_state.unwrap())
                },
            )
            .partition(Result::is_ok);
        end_timer!(succinct_time);

        if !failed_checks.is_empty() {
            Err(Error::FailedSuccinctCheck)?
        }

        let accumulators = accumulators
            .into_iter()
            .map(Result::unwrap)
            .collect::<Vec<_>>();

        Ok(accumulators)
    }
}

/// Evaluate the given polynomials at `query_set`.
pub fn evaluate_query_set<'a, F: Field>(
    polys: impl IntoIterator<Item = &'a LabeledPolynomial<F>>,
    query_set: &QuerySet<'a, F>,
) -> Evaluations<'a, F> {
    let polys = BTreeMap::from_iter(polys.into_iter().map(|p| (p.label(), p)));
    let mut evaluations = Evaluations::new();
    for (label, (_, point)) in query_set {
        let poly = polys
            .get(label)
            .expect("polynomial in evaluated lc is not found");
        let eval = poly.evaluate(*point);
        evaluations.insert((label.clone(), *point), eval);
    }
    evaluations
}

/// Evaluate the given polynomials at `query_set` and returns a Vec<((poly_label, point_label), eval)>)
pub fn evaluate_query_set_to_vec<'a, F: Field>(
    polys: impl IntoIterator<Item = &'a LabeledPolynomial<F>>,
    query_set: &QuerySet<'a, F>,
) -> Vec<((String, String), F)> {
    let polys = BTreeMap::from_iter(polys.into_iter().map(|p| (p.label(), p)));
    let mut v = Vec::new();
    for (label, (point_label, point)) in query_set {
        let poly = polys.get(label).expect(&*format!(
            "polynomial `{}` in evaluated lc is not found",
            label
        ));
        let eval = poly.evaluate(*point);
        v.push(((label.clone(), point_label.clone()), eval));
    }
    v
}
